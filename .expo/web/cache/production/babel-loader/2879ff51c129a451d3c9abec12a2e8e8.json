{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.updateDevicePushTokenAsync=updateDevicePushTokenAsync;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _backoff=require(\"@ide/backoff\");var Application=_interopRequireWildcard(require(\"expo-application\"));var _expoModulesCore=require(\"expo-modules-core\");var _ServerRegistrationModule=_interopRequireDefault(require(\"../ServerRegistrationModule\"));function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}var updateDevicePushTokenUrl='https://exp.host/--/api/v2/push/updateDeviceToken';function updateDevicePushTokenAsync(signal,token){var doUpdateDevicePushTokenAsync,shouldTry,retry,retriesCount,initialBackoff,backoffOptions,nextBackoffInterval;return _regenerator.default.async(function updateDevicePushTokenAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:doUpdateDevicePushTokenAsync=function doUpdateDevicePushTokenAsync(retry){var _await$Promise$all,_await$Promise$all2,development,deviceId,body,response;return _regenerator.default.async(function doUpdateDevicePushTokenAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _regenerator.default.awrap(Promise.all([shouldUseDevelopmentNotificationService(),getDeviceIdAsync()]));case 2:_await$Promise$all=_context.sent;_await$Promise$all2=(0,_slicedToArray2.default)(_await$Promise$all,2);development=_await$Promise$all2[0];deviceId=_await$Promise$all2[1];body={deviceId:deviceId.toLowerCase(),development:development,deviceToken:token.data,appId:Application.applicationId,type:getTypeOfToken(token)};_context.prev=7;_context.next=10;return _regenerator.default.awrap(fetch(updateDevicePushTokenUrl,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body),signal:signal}));case 10:response=_context.sent;if(response.ok){_context.next=17;break;}_context.t0=console;_context.next=15;return _regenerator.default.awrap(response.text());case 15:_context.t1=_context.sent;_context.t0.debug.call(_context.t0,'[expo-notifications] Error encountered while updating the device push token with the server:',_context.t1);case 17:if(!response.ok){retry();}_context.next=26;break;case 20:_context.prev=20;_context.t2=_context[\"catch\"](7);if(!(_context.t2.name==='AbortError')){_context.next=24;break;}return _context.abrupt(\"return\");case 24:console.warn('[expo-notifications] Error thrown while updating the device push token with the server:',_context.t2);retry();case 26:case\"end\":return _context.stop();}}},null,null,[[7,20]],Promise);};shouldTry=true;retry=function retry(){shouldTry=true;};retriesCount=0;initialBackoff=500;backoffOptions={maxBackoff:2*60*1000};nextBackoffInterval=(0,_backoff.computeNextBackoffInterval)(initialBackoff,retriesCount,backoffOptions);case 7:if(!(shouldTry&&!signal.aborted)){_context2.next=18;break;}shouldTry=false;_context2.next=11;return _regenerator.default.awrap(doUpdateDevicePushTokenAsync(retry));case 11:if(!(shouldTry&&!signal.aborted)){_context2.next=16;break;}nextBackoffInterval=(0,_backoff.computeNextBackoffInterval)(initialBackoff,retriesCount,backoffOptions);retriesCount+=1;_context2.next=16;return _regenerator.default.awrap(new Promise(function(resolve){return setTimeout(resolve,nextBackoffInterval);}));case 16:_context2.next=7;break;case 18:case\"end\":return _context2.stop();}}},null,null,null,Promise);}function getDeviceIdAsync(){return _regenerator.default.async(function getDeviceIdAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;if(_ServerRegistrationModule.default.getInstallationIdAsync){_context3.next=3;break;}throw new _expoModulesCore.UnavailabilityError('ExpoServerRegistrationModule','getInstallationIdAsync');case 3:_context3.next=5;return _regenerator.default.awrap(_ServerRegistrationModule.default.getInstallationIdAsync());case 5:return _context3.abrupt(\"return\",_context3.sent);case 8:_context3.prev=8;_context3.t0=_context3[\"catch\"](0);throw new _expoModulesCore.CodedError('ERR_NOTIFICATIONS_DEVICE_ID',\"Could not fetch the installation ID of the application: \"+_context3.t0+\".\");case 11:case\"end\":return _context3.stop();}}},null,null,[[0,8]],Promise);}function getTypeOfToken(devicePushToken){switch(devicePushToken.type){case'ios':return'apns';case'android':return'fcm';default:return devicePushToken.type;}}function shouldUseDevelopmentNotificationService(){var notificationServiceEnvironment;return _regenerator.default.async(function shouldUseDevelopmentNotificationService$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(_expoModulesCore.Platform.OS==='ios')){_context4.next=11;break;}_context4.prev=1;_context4.next=4;return _regenerator.default.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());case 4:notificationServiceEnvironment=_context4.sent;if(!(notificationServiceEnvironment==='development')){_context4.next=7;break;}return _context4.abrupt(\"return\",true);case 7:_context4.next=11;break;case 9:_context4.prev=9;_context4.t0=_context4[\"catch\"](1);case 11:return _context4.abrupt(\"return\",false);case 12:case\"end\":return _context4.stop();}}},null,null,[[1,9]],Promise);}","map":{"version":3,"sources":["../../src/utils/updateDevicePushTokenAsync.ts"],"names":[],"mappings":"qXAAA,qCACA,qEACA,kDAEA,6F,0/BAGA,GAAM,yBAAwB,CAAG,mDAAjC,CAEO,QAAe,2BAAf,CAA0C,MAA1C,CAA+D,KAA/D,0PACC,4BADD,CACgC,QAA/B,6BAA+B,CAAO,KAAP,yQACG,OAAO,CAAC,GAAR,CAAY,CAChD,uCAAuC,EADS,CAEhD,gBAAgB,EAFgC,CAAZ,CADH,gHAC5B,WAD4B,wBACf,QADe,wBAK7B,IAL6B,CAKtB,CACX,QAAQ,CAAE,QAAQ,CAAC,WAAT,EADC,CAEX,WAAW,CAAX,WAFW,CAGX,WAAW,CAAE,KAAK,CAAC,IAHR,CAIX,KAAK,CAAE,WAAW,CAAC,aAJR,CAKX,IAAI,CAAE,cAAc,CAAC,KAAD,CALT,CALsB,oEAcV,KAAK,CAAC,wBAAD,CAA2B,CACrD,MAAM,CAAE,MAD6C,CAErD,OAAO,CAAE,CACP,eAAgB,kBADT,CAF4C,CAKrD,IAAI,CAAE,IAAI,CAAC,SAAL,CAAe,IAAf,CAL+C,CAMrD,MAAM,CAAN,MANqD,CAA3B,CAdK,UAc3B,QAd2B,kBAwB5B,QAAQ,CAAC,EAxBmB,sCAyB/B,OAzB+B,oDA2BvB,QAAQ,CAAC,IAAT,EA3BuB,gDAyBvB,KAzBuB,kBA0B7B,8FA1B6B,sBAgCjC,GAAI,CAAC,QAAQ,CAAC,EAAd,CAAkB,CAChB,KAAK,GACN,CAlCgC,sFA0C7B,YAAE,IAAF,GAAW,YA1CkB,oEAiDjC,OAAO,CAAC,IAAR,CACE,yFADF,cAKA,KAAK,GAtD4B,0EADhC,CA2DD,SA3DC,CA2DW,IA3DX,CA4DC,KA5DD,CA4DS,QAAR,MAAQ,EAAK,CACjB,SAAS,CAAG,IAAZ,CACD,CA9DI,CAgED,YAhEC,CAgEc,CAhEd,CAiEC,cAjED,CAiEkB,GAjElB,CAkEC,cAlED,CAkEkB,CACrB,UAAU,CAAE,EAAI,EAAJ,CAAS,IADA,CAlElB,CAqED,mBArEC,CAqEqB,GAAA,mCAAA,EACxB,cADwB,CAExB,YAFwB,CAGxB,cAHwB,CArErB,aA2EE,SAAS,EAAI,CAAC,MAAM,CAAC,OA3EvB,4BA6EH,SAAS,CAAG,KAAZ,CA7EG,oDA8EG,4BAA4B,CAAC,KAAD,CA9E/B,eAiFC,SAAS,EAAI,CAAC,MAAM,CAAC,OAjFtB,4BAkFD,mBAAmB,CAAG,GAAA,mCAAA,EACpB,cADoB,CAEpB,YAFoB,CAGpB,cAHoB,CAAtB,CAKA,YAAY,EAAI,CAAhB,CAvFC,oDAwFK,GAAI,QAAJ,CAAY,SAAC,OAAD,QAAa,WAAU,CAAC,OAAD,CAAU,mBAAV,CAAvB,EAAZ,CAxFL,wGA8FP,QAAe,iBAAf,qJAES,iCAAA,CAAyB,sBAFlC,+BAGY,IAAI,qCAAJ,CAAwB,8BAAxB,CAAwD,wBAAxD,CAHZ,2DAMiB,iCAAA,CAAyB,sBAAzB,EANjB,0HAQU,IAAI,4BAAJ,CACJ,6BADI,6EARV,2EAgBA,QAAS,eAAT,CAAwB,eAAxB,CAAwD,CACtD,OAAQ,eAAe,CAAC,IAAxB,EACE,IAAK,KAAL,CACE,MAAO,MAAP,CACF,IAAK,SAAL,CACE,MAAO,KAAP,CAEF,QACE,MAAO,gBAAe,CAAC,IAAvB,CAPJ,CASD,CAGD,QAAe,wCAAf,gMACM,yBAAA,CAAS,EAAT,GAAgB,KADtB,gGAIc,WAAW,CAAC,6CAAZ,EAJd,SAGY,8BAHZ,qBAKU,8BAA8B,GAAK,aAL7C,4DAMe,IANf,qIAaS,KAbT","sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport * as Application from 'expo-application';\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updateDevicePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdateDevicePushTokenAsync = async (retry: () => void) => {\n    const [development, deviceId] = await Promise.all([\n      shouldUseDevelopmentNotificationService(),\n      getDeviceIdAsync(),\n    ]);\n    const body = {\n      deviceId: deviceId.toLowerCase(),\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token),\n    };\n\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating the device push token with the server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      // Error returned if the request is aborted should be an 'AbortError'. In\n      // React Native fetch is polyfilled using `whatwg-fetch` which:\n      // - creates `AbortError`s like this\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n      // - which creates exceptions like\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n      if (e.name === 'AbortError') {\n        // We don't consider AbortError a failure, it's a sign somewhere else the\n        // request is expected to succeed and we don't need this one, so let's\n        // just return.\n        return;\n      }\n\n      console.warn(\n        '[expo-notifications] Error thrown while updating the device push token with the server:',\n        e\n      );\n\n      retry();\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise((resolve) => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not fetch the installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}