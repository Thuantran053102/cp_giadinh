{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.__handlePersistedRegistrationInfoAsync=__handlePersistedRegistrationInfoAsync;exports.setAutoServerRegistrationEnabledAsync=setAutoServerRegistrationEnabledAsync;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));require(\"abort-controller/polyfill\");var _expoModulesCore=require(\"expo-modules-core\");var _ServerRegistrationModule=_interopRequireDefault(require(\"./ServerRegistrationModule\"));var _TokenEmitter=require(\"./TokenEmitter\");var _getDevicePushTokenAsync=_interopRequireDefault(require(\"./getDevicePushTokenAsync\"));var _updateDevicePushTokenAsync=require(\"./utils/updateDevicePushTokenAsync\");var lastAbortController=null;function updatePushTokenAsync(token){var _lastAbortController;return _regenerator.default.async(function updatePushTokenAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:(_lastAbortController=lastAbortController)==null?void 0:_lastAbortController.abort();lastAbortController=new AbortController();_context.next=4;return _regenerator.default.awrap((0,_updateDevicePushTokenAsync.updateDevicePushTokenAsync)(lastAbortController.signal,token));case 4:return _context.abrupt(\"return\",_context.sent);case 5:case\"end\":return _context.stop();}}},null,null,null,Promise);}function setAutoServerRegistrationEnabledAsync(enabled){var _lastAbortController2;return _regenerator.default.async(function setAutoServerRegistrationEnabledAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:(_lastAbortController2=lastAbortController)==null?void 0:_lastAbortController2.abort();if(_ServerRegistrationModule.default.setRegistrationInfoAsync){_context2.next=3;break;}throw new _expoModulesCore.UnavailabilityError('ServerRegistrationModule','setRegistrationInfoAsync');case 3:_context2.next=5;return _regenerator.default.awrap(_ServerRegistrationModule.default.setRegistrationInfoAsync(enabled?JSON.stringify({isEnabled:enabled}):null));case 5:case\"end\":return _context2.stop();}}},null,null,null,Promise);}function __handlePersistedRegistrationInfoAsync(registrationInfo){var _registration;var registration,latestDevicePushToken;return _regenerator.default.async(function __handlePersistedRegistrationInfoAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(registrationInfo){_context3.next=2;break;}return _context3.abrupt(\"return\");case 2:registration=null;try{registration=JSON.parse(registrationInfo);}catch(e){console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.',e);}if((_registration=registration)!=null&&_registration.isEnabled){_context3.next=6;break;}return _context3.abrupt(\"return\");case 6:_context3.prev=6;_context3.next=9;return _regenerator.default.awrap((0,_getDevicePushTokenAsync.default)());case 9:latestDevicePushToken=_context3.sent;_context3.next=12;return _regenerator.default.awrap(updatePushTokenAsync(latestDevicePushToken));case 12:_context3.next=17;break;case 14:_context3.prev=14;_context3.t0=_context3[\"catch\"](6);console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',_context3.t0);case 17:case\"end\":return _context3.stop();}}},null,null,[[6,14]],Promise);}if(_ServerRegistrationModule.default.getRegistrationInfoAsync){(0,_TokenEmitter.addPushTokenListener)(function _callee(token){var registrationInfo,registration;return _regenerator.default.async(function _callee$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.prev=0;_context4.next=3;return _regenerator.default.awrap(_ServerRegistrationModule.default.getRegistrationInfoAsync());case 3:registrationInfo=_context4.sent;if(registrationInfo){_context4.next=6;break;}return _context4.abrupt(\"return\");case 6:registration=JSON.parse(registrationInfo);if(!(registration!=null&&registration.isEnabled)){_context4.next=10;break;}_context4.next=10;return _regenerator.default.awrap(updatePushTokenAsync(token));case 10:_context4.next=15;break;case 12:_context4.prev=12;_context4.t0=_context4[\"catch\"](0);console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',_context4.t0);case 15:case\"end\":return _context4.stop();}}},null,null,[[0,12]],Promise);});_ServerRegistrationModule.default.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);}else{console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\",new _expoModulesCore.UnavailabilityError('ServerRegistrationModule','getRegistrationInfoAsync'));}","map":{"version":3,"sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"qYAAA,qCACA,kDAEA,4FACA,4CAEA,0FACA,8EAEA,GAAI,oBAAmB,CAA2B,IAAlD,CACA,QAAe,qBAAf,CAAoC,KAApC,0JAEE,sBAAA,mBAAmB,OAAnB,6BAAqB,KAArB,GACA,mBAAmB,CAAG,GAAI,gBAAJ,EAAtB,CAHF,kDAIe,GAAA,sDAAA,EAAqC,mBAAmB,CAAC,MAAzD,CAAiE,KAAjE,CAJf,6HAmBO,QAAe,sCAAf,CAAqD,OAArD,+KAGL,uBAAA,mBAAmB,OAAnB,8BAAqB,KAArB,GAHK,GAKA,iCAAA,CAAyB,wBALzB,+BAMG,IAAI,qCAAJ,CAAwB,0BAAxB,CAAoD,0BAApD,CANH,2DASC,iCAAA,CAAyB,wBAAzB,CACJ,OAAO,CAAG,IAAI,CAAC,SAAL,CAAe,CAAE,SAAS,CAAE,OAAb,CAAf,CAAH,CAA4C,IAD/C,CATD,wEAiBA,QAAe,uCAAf,CACL,gBADK,kNAGA,gBAHA,mEAQD,YARC,CAQkD,IARlD,CASL,GAAI,CACF,YAAY,CAAG,IAAI,CAAC,KAAL,CAAW,gBAAX,CAAf,CACD,CAAC,MAAO,CAAP,CAAU,CACV,OAAO,CAAC,IAAR,CACE,wGADF,CAEE,CAFF,EAID,CAhBI,kBAkBA,YAlBA,SAkBA,cAAc,SAlBd,uIA0BiC,GAAA,gCAAA,GA1BjC,SA0BG,qBA1BH,oEA2BG,oBAAoB,CAAC,qBAAD,CA3BvB,+FA6BH,OAAO,CAAC,IAAR,CACE,0GADF,eA7BG,2EAoCP,GAAI,iCAAA,CAAyB,wBAA7B,CAAuD,CAGrD,GAAA,kCAAA,EAAqB,iBAAO,KAAP,6NAKc,iCAAA,CAAyB,wBAAzB,EALd,SAKX,gBALW,mBAOZ,gBAPY,mEAYX,YAZW,CAYwC,IAAI,CAAC,KAAL,CAAW,gBAAX,CAZxC,MAab,YAba,QAab,YAAY,CAAE,SAbD,gFAgBT,oBAAoB,CAAC,KAAD,CAhBX,+FAmBjB,OAAO,CAAC,IAAR,CACE,0GADF,eAnBiB,2EAArB,EA6BA,iCAAA,CAAyB,wBAAzB,GAAoD,IAApD,CAAyD,sCAAzD,EACD,CAjCD,IAiCO,CACL,OAAO,CAAC,IAAR,6IAEE,GAAI,qCAAJ,CAAwB,0BAAxB,CAAoD,0BAApD,CAFF,EAID","sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}