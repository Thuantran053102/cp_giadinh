{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.evaluateOnce=evaluateOnce;var _InternalAnimatedValue=_interopRequireDefault(require(\"../core/InternalAnimatedValue\"));var _AnimatedSet=require(\"../core/AnimatedSet\");var _AnimatedCall=require(\"../core/AnimatedCall\");var _AnimatedAlways=require(\"../core/AnimatedAlways\");var _AnimatedCond=require(\"../core/AnimatedCond\");function evaluateOnce(node){var input=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var callback=arguments.length>2?arguments[2]:undefined;if(!Array.isArray(input)){input=[input];}var done=new _InternalAnimatedValue.default(0);var evalNode=(0,_AnimatedCond.createAnimatedCond)(done,0,(0,_AnimatedCall.createAnimatedCall)([node,(0,_AnimatedSet.createAnimatedSet)(done,1)],function(){callback&&callback();for(var i=0;i<input.length;i++){input[i].__removeChild(alwaysNode);alwaysNode.__detach();}}));var alwaysNode=(0,_AnimatedAlways.createAnimatedAlways)(evalNode);for(var i=0;i<input.length;i++){input[i].__addChild(alwaysNode);alwaysNode.__attach();}}","map":{"version":3,"names":["evaluateOnce","node","input","callback","Array","isArray","done","AnimatedValue","evalNode","cond","call","set","i","length","__removeChild","alwaysNode","__detach","always","__addChild","__attach"],"sources":["D:/React_Native/SourceCode_VPM_Swine/node_modules/react-native-reanimated/lib/reanimated1/derived/evaluateOnce.js"],"sourcesContent":["import AnimatedValue from '../core/InternalAnimatedValue';\nimport { createAnimatedSet as set } from '../core/AnimatedSet';\nimport { createAnimatedCall as call } from '../core/AnimatedCall';\nimport { createAnimatedAlways as always } from '../core/AnimatedAlways';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\n\n/**\n * evaluate given node and notify children\n * @param node - node to be evaluated\n * @param input - nodes (or one node) representing values which states input for node.\n * @param callback - after callback\n */\n\nexport function evaluateOnce(node, input = [], callback) {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  const done = new AnimatedValue(0);\n  const evalNode = cond(\n    done,\n    0,\n    call([node, set(done, 1)], () => {\n      callback && callback();\n      for (let i = 0; i < input.length; i++) {\n        input[i].__removeChild(alwaysNode);\n        alwaysNode.__detach();\n      }\n    })\n  );\n  const alwaysNode = always(evalNode);\n  for (let i = 0; i < input.length; i++) {\n    input[i].__addChild(alwaysNode);\n    alwaysNode.__attach();\n  }\n}\n"],"mappings":"8KAAA,4FACA,gDACA,kDACA,sDACA,kDASO,QAASA,aAAT,CAAsBC,IAAtB,CAAkD,IAAtBC,MAAsB,2DAAd,EAAc,IAAVC,SAAU,2CACvD,GAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAAL,CAA2B,CACzBA,KAAK,CAAG,CAACA,KAAD,CAAR,CACD,CACD,GAAMI,KAAI,CAAG,GAAIC,+BAAJ,CAAkB,CAAlB,CAAb,CACA,GAAMC,SAAQ,CAAG,GAAAC,gCAAA,EACfH,IADe,CAEf,CAFe,CAGf,GAAAI,gCAAA,EAAK,CAACT,IAAD,CAAO,GAAAU,8BAAA,EAAIL,IAAJ,CAAU,CAAV,CAAP,CAAL,CAA2B,UAAM,CAC/BH,QAAQ,EAAIA,QAAQ,EAApB,CACA,IAAK,GAAIS,EAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGV,KAAK,CAACW,MAA1B,CAAkCD,CAAC,EAAnC,CAAuC,CACrCV,KAAK,CAACU,CAAD,CAAL,CAASE,aAAT,CAAuBC,UAAvB,EACAA,UAAU,CAACC,QAAX,GACD,CACF,CAND,CAHe,CAAjB,CAWA,GAAMD,WAAU,CAAG,GAAAE,oCAAA,EAAOT,QAAP,CAAnB,CACA,IAAK,GAAII,EAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGV,KAAK,CAACW,MAA1B,CAAkCD,CAAC,EAAnC,CAAuC,CACrCV,KAAK,CAACU,CAAD,CAAL,CAASM,UAAT,CAAoBH,UAApB,EACAA,UAAU,CAACI,QAAX,GACD,CACF"},"metadata":{},"sourceType":"script"}