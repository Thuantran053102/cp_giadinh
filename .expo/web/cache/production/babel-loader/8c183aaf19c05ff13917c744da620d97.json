{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.Constants=exports.BarCodeScanner=void 0;Object.defineProperty(exports,\"PermissionStatus\",{enumerable:true,get:function get(){return _expoModulesCore.PermissionStatus;}});exports.usePermissions=exports.scanFromURLAsync=exports.requestPermissionsAsync=exports.getPermissionsAsync=void 0;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _expoModulesCore=require(\"expo-modules-core\");var React=_interopRequireWildcard(require(\"react\"));var _reactNative=require(\"react-native\");var _ExpoBarCodeScannerModule=_interopRequireDefault(require(\"./ExpoBarCodeScannerModule\"));var _ExpoBarCodeScannerView=_interopRequireDefault(require(\"./ExpoBarCodeScannerView\"));function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}var BarCodeType=_ExpoBarCodeScannerModule.default.BarCodeType,Type=_ExpoBarCodeScannerModule.default.Type;var EVENT_THROTTLE_MS=500;var BarCodeScanner=function(_React$Component){(0,_inherits2.default)(BarCodeScanner,_React$Component);var _super=_createSuper(BarCodeScanner);function BarCodeScanner(){var _this;(0,_classCallCheck2.default)(this,BarCodeScanner);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.lastEvents={};_this.lastEventsTimes={};_this.onObjectDetected=function(callback){return function(_ref){var nativeEvent=_ref.nativeEvent;var type=nativeEvent.type;if(_this.lastEvents[type]&&_this.lastEventsTimes[type]&&JSON.stringify(nativeEvent)===_this.lastEvents[type]&&Date.now()-_this.lastEventsTimes[type]<EVENT_THROTTLE_MS){return;}if(callback){callback(nativeEvent);_this.lastEventsTimes[type]=new Date();_this.lastEvents[type]=JSON.stringify(nativeEvent);}};};return _this;}(0,_createClass2.default)(BarCodeScanner,[{key:\"render\",value:function render(){var nativeProps=this.convertNativeProps(this.props);var onBarCodeScanned=this.props.onBarCodeScanned;return React.createElement(_ExpoBarCodeScannerView.default,(0,_extends2.default)({},nativeProps,{onBarCodeScanned:this.onObjectDetected(onBarCodeScanned)}));}},{key:\"convertNativeProps\",value:function convertNativeProps(props){var nativeProps={};for(var _i=0,_Object$entries=Object.entries(props);_i<_Object$entries.length;_i++){var _ref2=_Object$entries[_i];var _ref3=(0,_slicedToArray2.default)(_ref2,2);var key=_ref3[0];var value=_ref3[1];if(typeof value==='string'&&BarCodeScanner.ConversionTables[key]){nativeProps[key]=BarCodeScanner.ConversionTables[key][value];}else{nativeProps[key]=value;}}return nativeProps;}}],[{key:\"getPermissionsAsync\",value:function getPermissionsAsync(){return _regenerator.default.async(function getPermissionsAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",_ExpoBarCodeScannerModule.default.getPermissionsAsync());case 1:case\"end\":return _context.stop();}}},null,null,null,Promise);}},{key:\"requestPermissionsAsync\",value:function requestPermissionsAsync(){return _regenerator.default.async(function requestPermissionsAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:return _context2.abrupt(\"return\",_ExpoBarCodeScannerModule.default.requestPermissionsAsync());case 1:case\"end\":return _context2.stop();}}},null,null,null,Promise);}},{key:\"scanFromURLAsync\",value:function scanFromURLAsync(url){var barCodeTypes,_args3=arguments;return _regenerator.default.async(function scanFromURLAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:barCodeTypes=_args3.length>1&&_args3[1]!==undefined?_args3[1]:Object.values(BarCodeType);if(_ExpoBarCodeScannerModule.default.scanFromURLAsync){_context3.next=3;break;}throw new _expoModulesCore.UnavailabilityError('expo-barcode-scanner','scanFromURLAsync');case 3:if(!(Array.isArray(barCodeTypes)&&!barCodeTypes.length)){_context3.next=5;break;}throw new Error('No barCodeTypes specified; provide at least one barCodeType for scanner');case 5:if(!(_reactNative.Platform.OS==='ios')){_context3.next=11;break;}if(!(Array.isArray(barCodeTypes)&&!barCodeTypes.includes(BarCodeType.qr))){_context3.next=8;break;}throw new Error('Only QR type is supported by scanFromURLAsync() on iOS');case 8:_context3.next=10;return _regenerator.default.awrap(_ExpoBarCodeScannerModule.default.scanFromURLAsync(url,[BarCodeType.qr]));case 10:return _context3.abrupt(\"return\",_context3.sent);case 11:_context3.next=13;return _regenerator.default.awrap(_ExpoBarCodeScannerModule.default.scanFromURLAsync(url,barCodeTypes));case 13:return _context3.abrupt(\"return\",_context3.sent);case 14:case\"end\":return _context3.stop();}}},null,null,null,Promise);}}]);return BarCodeScanner;}(React.Component);exports.BarCodeScanner=BarCodeScanner;BarCodeScanner.Constants={BarCodeType:BarCodeType,Type:Type};BarCodeScanner.ConversionTables={type:Type};BarCodeScanner.defaultProps={type:Type.back,barCodeTypes:Object.values(BarCodeType)};BarCodeScanner.usePermissions=(0,_expoModulesCore.createPermissionHook)({getMethod:BarCodeScanner.getPermissionsAsync,requestMethod:BarCodeScanner.requestPermissionsAsync});var Constants=BarCodeScanner.Constants,getPermissionsAsync=BarCodeScanner.getPermissionsAsync,requestPermissionsAsync=BarCodeScanner.requestPermissionsAsync,usePermissions=BarCodeScanner.usePermissions,scanFromURLAsync=BarCodeScanner.scanFromURLAsync;exports.scanFromURLAsync=scanFromURLAsync;exports.usePermissions=usePermissions;exports.requestPermissionsAsync=requestPermissionsAsync;exports.getPermissionsAsync=getPermissionsAsync;exports.Constants=Constants;","map":{"version":3,"sources":["../src/BarCodeScanner.tsx"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport * as React from 'react';\nimport { Platform, ViewProps } from 'react-native';\n\nimport ExpoBarCodeScannerModule from './ExpoBarCodeScannerModule';\nimport ExpoBarCodeScannerView from './ExpoBarCodeScannerView';\n\nconst { BarCodeType, Type } = ExpoBarCodeScannerModule;\n\nconst EVENT_THROTTLE_MS = 500;\n\n// @needsAudit\n/**\n * Those coordinates are represented in the coordinate space of the barcode source (e.g. when you\n * are using the barcode scanner view, these values are adjusted to the dimensions of the view).\n */\nexport type BarCodePoint = {\n  /**\n   * The `x` coordinate value.\n   */\n  x: number;\n  /**\n   * The `y` coordinate value.\n   */\n  y: number;\n};\n\n// @needsAudit\nexport type BarCodeSize = {\n  /**\n   * The height value.\n   */\n  height: number;\n  /**\n   * The width value.\n   */\n  width: number;\n};\n\n// @needsAudit\nexport type BarCodeBounds = {\n  /**\n   * The origin point of the bounding box.\n   */\n  origin: BarCodePoint;\n  /**\n   * The size of the bounding box.\n   */\n  size: BarCodeSize;\n};\n\n// @needsAudit\n/**\n * > __Note:__ `bounds` and `cornerPoints` are not always available. On iOS, for `code39` and `pdf417`\n * > you don't get those values. Moreover, on iOS, those values don't have to bounds the whole barcode.\n * > For some types, they will represent the area used by the scanner.\n */\nexport type BarCodeScannerResult = {\n  /**\n   * The barcode type.\n   */\n  type: string;\n  /**\n   * The information encoded in the bar code.\n   */\n  data: string;\n  /**\n   * The [BarCodeBounds](#barcodebounds) object.\n   */\n  bounds?: BarCodeBounds;\n  /**\n   * Corner points of the bounding box.\n   */\n  cornerPoints?: BarCodePoint[];\n};\n\n// @docsMissing\nexport type BarCodeEvent = BarCodeScannerResult & {\n  target?: number;\n};\n\n// @docsMissing\nexport type BarCodeEventCallbackArguments = {\n  nativeEvent: BarCodeEvent;\n};\n\n// @docsMissing\nexport type BarCodeScannedCallback = (params: BarCodeEvent) => void;\n\n// @needsAudit\nexport type BarCodeScannerProps = ViewProps & {\n  /**\n   * Camera facing. Use one of `BarCodeScanner.Constants.Type`. Use either `Type.front` or `Type.back`.\n   * Same as `Camera.Constants.Type`.\n   * @default Type.back\n   */\n  type?: 'front' | 'back' | number;\n  /**\n   * An array of bar code types. Usage: `BarCodeScanner.Constants.BarCodeType.<codeType>` where\n   * `codeType` is one of these [listed above](#supported-formats). Defaults to all supported bar\n   * code types. It is recommended to provide only the bar code formats you expect to scan to\n   * minimize battery usage.\n   *\n   * For example: `barCodeTypes={[BarCodeScanner.Constants.BarCodeType.qr]}`.\n   */\n  barCodeTypes?: string[];\n  /**\n   * A callback that is invoked when a bar code has been successfully scanned. The callback is\n   * provided with an [BarCodeScannerResult](#barcodescannerresult).\n   * > __Note:__ Passing `undefined` to the `onBarCodeScanned` prop will result in no scanning. This\n   * > can be used to effectively \"pause\" the scanner so that it doesn't continually scan even after\n   * > data has been retrieved.\n   */\n  onBarCodeScanned?: BarCodeScannedCallback;\n};\n\nexport class BarCodeScanner extends React.Component<BarCodeScannerProps> {\n  lastEvents: { [key: string]: any } = {};\n  lastEventsTimes: { [key: string]: any } = {};\n\n  static Constants = {\n    BarCodeType,\n    Type,\n  };\n\n  static ConversionTables = {\n    type: Type,\n  };\n\n  static defaultProps = {\n    type: Type.back,\n    barCodeTypes: Object.values(BarCodeType),\n  };\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing the camera.\n   * @return Return a promise that fulfills to an object of type [`PermissionResponse`](#permissionresponse).\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    return ExpoBarCodeScannerModule.getPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing the camera.\n   *\n   * On iOS this will require apps to specify the `NSCameraUsageDescription` entry in the `Info.plist`.\n   * @return Return a promise that fulfills to an object of type [`PermissionResponse`](#permissionresponse).\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    return ExpoBarCodeScannerModule.requestPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions for the barcode scanner.\n   * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = BarCodeScanner.usePermissions();\n   * ```\n   */\n  static usePermissions = createPermissionHook({\n    getMethod: BarCodeScanner.getPermissionsAsync,\n    requestMethod: BarCodeScanner.requestPermissionsAsync,\n  });\n\n  // @needsAudit\n  /**\n   * Scan bar codes from the image given by the URL.\n   * @param url URL to get the image from.\n   * @param barCodeTypes An array of bar code types. Defaults to all supported bar code types on\n   * the platform.\n   * > __Note:__ Only QR codes are supported on iOS.\n   * @return A possibly empty array of objects of the `BarCodeScannerResult` shape, where the type\n   * refers to the bar code type that was scanned and the data is the information encoded in the bar\n   * code.\n   */\n  static async scanFromURLAsync(\n    url: string,\n    barCodeTypes: string[] = Object.values(BarCodeType)\n  ): Promise<BarCodeScannerResult[]> {\n    if (!ExpoBarCodeScannerModule.scanFromURLAsync) {\n      throw new UnavailabilityError('expo-barcode-scanner', 'scanFromURLAsync');\n    }\n    if (Array.isArray(barCodeTypes) && !barCodeTypes.length) {\n      throw new Error('No barCodeTypes specified; provide at least one barCodeType for scanner');\n    }\n\n    if (Platform.OS === 'ios') {\n      if (Array.isArray(barCodeTypes) && !barCodeTypes.includes(BarCodeType.qr)) {\n        // Only QR type is supported on iOS, fail if one tries to use other types\n        throw new Error('Only QR type is supported by scanFromURLAsync() on iOS');\n      }\n      // on iOS use only supported QR type\n      return await ExpoBarCodeScannerModule.scanFromURLAsync(url, [BarCodeType.qr]);\n    }\n\n    // On other platforms, if barCodeTypes is not provided, use all available types\n    return await ExpoBarCodeScannerModule.scanFromURLAsync(url, barCodeTypes);\n  }\n\n  render() {\n    const nativeProps = this.convertNativeProps(this.props);\n    const { onBarCodeScanned } = this.props;\n    return (\n      <ExpoBarCodeScannerView\n        {...nativeProps}\n        onBarCodeScanned={this.onObjectDetected(onBarCodeScanned)}\n      />\n    );\n  }\n\n  onObjectDetected =\n    (callback?: BarCodeScannedCallback) =>\n    ({ nativeEvent }: BarCodeEventCallbackArguments) => {\n      const { type } = nativeEvent;\n      if (\n        this.lastEvents[type] &&\n        this.lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this.lastEvents[type] &&\n        Date.now() - this.lastEventsTimes[type] < EVENT_THROTTLE_MS\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this.lastEventsTimes[type] = new Date();\n        this.lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  convertNativeProps(props: BarCodeScannerProps) {\n    const nativeProps: BarCodeScannerProps = {};\n\n    for (const [key, value] of Object.entries(props)) {\n      if (typeof value === 'string' && BarCodeScanner.ConversionTables[key]) {\n        nativeProps[key] = BarCodeScanner.ConversionTables[key][value];\n      } else {\n        nativeProps[key] = value;\n      }\n    }\n\n    return nativeProps;\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  usePermissions,\n  scanFromURLAsync,\n} = BarCodeScanner;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}