{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=useLastNotificationResponse;var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _react=require(\"react\");var _NotificationsEmitter=require(\"./NotificationsEmitter\");var _NotificationsEmitterModule=_interopRequireDefault(require(\"./NotificationsEmitterModule\"));function useLastNotificationResponse(){var _useState=(0,_react.useState)(undefined),_useState2=(0,_slicedToArray2.default)(_useState,2),lastNotificationResponse=_useState2[0],setLastNotificationResponse=_useState2[1];(0,_react.useLayoutEffect)(function(){var subscription=(0,_NotificationsEmitter.addNotificationResponseReceivedListener)(function(response){setLastNotificationResponse(response);});return function(){subscription.remove();};},[]);(0,_react.useEffect)(function(){_NotificationsEmitterModule.default.getLastNotificationResponseAsync==null?void 0:_NotificationsEmitterModule.default.getLastNotificationResponseAsync().then(function(response){setLastNotificationResponse(function(currentResponse){return currentResponse!=null?currentResponse:response;});});},[]);return lastNotificationResponse;}","map":{"version":3,"sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"oRAAA,4BAGA,4DACA,gGASc,QAAU,4BAAV,EAAqC,CACjD,cAAgE,GAAA,eAAA,EAE9D,SAF8D,CAAhE,qDAAO,wBAAP,eAAiC,2BAAjC,eAKA,GAAA,sBAAA,EAAgB,UAAK,CACnB,GAAM,aAAY,CAAG,GAAA,6DAAA,EAAwC,SAAC,QAAD,CAAa,CACxE,2BAA2B,CAAC,QAAD,CAA3B,CACD,CAFoB,CAArB,CAGA,MAAO,WAAK,CACV,YAAY,CAAC,MAAb,GACD,CAFD,CAGD,CAPD,CAOG,EAPH,EAYA,GAAA,gBAAA,EAAU,UAAK,CACb,mCAAA,CAA2B,gCAA3B,cAAA,mCAAA,CAA2B,gCAA3B,GAAgE,IAAhE,CAAqE,SAAC,QAAD,CAAa,CAIhF,2BAA2B,CAAC,SAAC,eAAD,QAAqB,gBAArB,OAAqB,eAArB,CAAwC,QAAxC,EAAD,CAA3B,CACD,CALD,EAMD,CAPD,CAOG,EAPH,EASA,MAAO,yBAAP,CACD","sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n/**\n * Return value of this hook may be one of three types:\n * - `undefined` until we know what to return\n * - `null` until the app receives any notification response\n * - an object of `NotificationResponse` type - the response\n *   that has been received by the app most recently.\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      setLastNotificationResponse(response);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      setLastNotificationResponse((currentResponse) => currentResponse ?? response);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}