{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.Extrapolation=void 0;exports.interpolate=interpolate;var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _interpolate=_interopRequireDefault(require(\"../reanimated1/derived/interpolate\"));var Extrapolation;exports.Extrapolation=Extrapolation;(function(Extrapolation){Extrapolation[\"IDENTITY\"]=\"identity\";Extrapolation[\"CLAMP\"]=\"clamp\";Extrapolation[\"EXTEND\"]=\"extend\";})(Extrapolation||(exports.Extrapolation=Extrapolation={}));function isNode(x){'worklet';return x.__nodeId!==undefined;}function getVal(type,coef,val,leftEdgeOutput,rightEdgeOutput,x){'worklet';switch(type){case Extrapolation.IDENTITY:return x;case Extrapolation.CLAMP:if(coef*val<coef*leftEdgeOutput){return leftEdgeOutput;}return rightEdgeOutput;case Extrapolation.EXTEND:default:return val;}}function isExtrapolate(value){'worklet';return value===Extrapolation.EXTEND||value===Extrapolation.CLAMP||value===Extrapolation.IDENTITY;}function validateType(type){'worklet';var extrapolationConfig={extrapolateLeft:Extrapolation.EXTEND,extrapolateRight:Extrapolation.EXTEND};if(!type){return extrapolationConfig;}if(typeof type==='string'){if(!isExtrapolate(type)){throw new Error(\"Reanimated: not supported value for \\\"interpolate\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\\n        interpolate(value, [inputRange], [outputRange], \\\"clamp\\\")\");}extrapolationConfig.extrapolateLeft=type;extrapolationConfig.extrapolateRight=type;return extrapolationConfig;}if(type.extrapolateLeft&&!isExtrapolate(type.extrapolateLeft)||type.extrapolateRight&&!isExtrapolate(type.extrapolateRight)){throw new Error(\"Reanimated: not supported value for \\\"interpolate\\\" \\nSupported values: [\\\"extend\\\", \\\"clamp\\\", \\\"identity\\\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\\n      interpolate(value, [inputRange], [outputRange], {\\n        extrapolateLeft: Extrapolation.CLAMP,\\n        extrapolateRight: Extrapolation.IDENTITY\\n      }})\");}(0,_extends2.default)(extrapolationConfig,type);return extrapolationConfig;}function internalInterpolate(x,narrowedInput,extrapolationConfig){'worklet';var leftEdgeInput=narrowedInput.leftEdgeInput,rightEdgeInput=narrowedInput.rightEdgeInput,leftEdgeOutput=narrowedInput.leftEdgeOutput,rightEdgeOutput=narrowedInput.rightEdgeOutput;if(rightEdgeInput-leftEdgeInput===0)return leftEdgeOutput;var progress=(x-leftEdgeInput)/(rightEdgeInput-leftEdgeInput);var val=leftEdgeOutput+progress*(rightEdgeOutput-leftEdgeOutput);var coef=rightEdgeOutput>=leftEdgeOutput?1:-1;if(coef*val<coef*leftEdgeOutput){return getVal(extrapolationConfig.extrapolateLeft,coef,val,leftEdgeOutput,rightEdgeOutput,x);}else if(coef*val>coef*rightEdgeOutput){return getVal(extrapolationConfig.extrapolateRight,coef,val,leftEdgeOutput,rightEdgeOutput,x);}return val;}function interpolate(x,input,output,type){'worklet';if(input.length<2||output.length<2){throw Error('Interpolation input and output should contain at least two values.');}var extrapolationConfig=validateType(type);if(isNode(x)){console.warn(\"interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead\");return(0,_interpolate.default)(x,{inputRange:input,outputRange:output,extrapolateLeft:extrapolationConfig.extrapolateLeft,extrapolateRight:extrapolationConfig.extrapolateRight});}var length=input.length;var narrowedInput={leftEdgeInput:input[0],rightEdgeInput:input[1],leftEdgeOutput:output[0],rightEdgeOutput:output[1]};if(length>2){if(x>input[length-1]){narrowedInput.leftEdgeInput=input[length-2];narrowedInput.rightEdgeInput=input[length-1];narrowedInput.leftEdgeOutput=output[length-2];narrowedInput.rightEdgeOutput=output[length-1];}else{for(var i=1;i<length;++i){if(x<=input[i]){narrowedInput.leftEdgeInput=input[i-1];narrowedInput.rightEdgeInput=input[i];narrowedInput.leftEdgeOutput=output[i-1];narrowedInput.rightEdgeOutput=output[i];break;}}}}return internalInterpolate(x,narrowedInput,extrapolationConfig);}","map":{"version":3,"names":["Extrapolation","isNode","x","__nodeId","undefined","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateType","extrapolationConfig","extrapolateLeft","extrapolateRight","Error","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","progress","interpolate","input","output","length","console","warn","interpolateNode","inputRange","outputRange","i"],"sources":["D:/React_Native/SourceCode_VPM_Swine/node_modules/react-native-reanimated/lib/reanimated2/interpolation.js"],"sourcesContent":["// @ts-ignore JS file\nimport interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n(function (Extrapolation) {\n    Extrapolation[\"IDENTITY\"] = \"identity\";\n    Extrapolation[\"CLAMP\"] = \"clamp\";\n    Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\nfunction isNode(x) {\n    'worklet';\n    return x.__nodeId !== undefined;\n}\nfunction getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n    'worklet';\n    switch (type) {\n        case Extrapolation.IDENTITY:\n            return x;\n        case Extrapolation.CLAMP:\n            if (coef * val < coef * leftEdgeOutput) {\n                return leftEdgeOutput;\n            }\n            return rightEdgeOutput;\n        case Extrapolation.EXTEND:\n        default:\n            return val;\n    }\n}\nfunction isExtrapolate(value) {\n    'worklet';\n    return (value === Extrapolation.EXTEND ||\n        value === Extrapolation.CLAMP ||\n        value === Extrapolation.IDENTITY);\n}\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nfunction validateType(type) {\n    'worklet';\n    // initialize extrapolationConfig with default extrapolation\n    const extrapolationConfig = {\n        extrapolateLeft: Extrapolation.EXTEND,\n        extrapolateRight: Extrapolation.EXTEND,\n    };\n    if (!type) {\n        return extrapolationConfig;\n    }\n    if (typeof type === 'string') {\n        if (!isExtrapolate(type)) {\n            throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n        }\n        extrapolationConfig.extrapolateLeft = type;\n        extrapolationConfig.extrapolateRight = type;\n        return extrapolationConfig;\n    }\n    // otherwise type is extrapolation config object\n    if ((type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n        (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))) {\n        throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n    }\n    Object.assign(extrapolationConfig, type);\n    return extrapolationConfig;\n}\nfunction internalInterpolate(x, narrowedInput, extrapolationConfig) {\n    'worklet';\n    const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput, } = narrowedInput;\n    if (rightEdgeInput - leftEdgeInput === 0)\n        return leftEdgeOutput;\n    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n    if (coef * val < coef * leftEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    else if (coef * val > coef * rightEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    return val;\n}\n// TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\nexport function interpolate(x, input, output, type) {\n    'worklet';\n    if (input.length < 2 || output.length < 2) {\n        throw Error('Interpolation input and output should contain at least two values.');\n    }\n    const extrapolationConfig = validateType(type);\n    if (isNode(x)) {\n        console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n        return interpolateNode(x, {\n            inputRange: input,\n            outputRange: output,\n            extrapolateLeft: extrapolationConfig.extrapolateLeft,\n            extrapolateRight: extrapolationConfig.extrapolateRight,\n        });\n    }\n    const length = input.length;\n    const narrowedInput = {\n        leftEdgeInput: input[0],\n        rightEdgeInput: input[1],\n        leftEdgeOutput: output[0],\n        rightEdgeOutput: output[1],\n    };\n    if (length > 2) {\n        if (x > input[length - 1]) {\n            narrowedInput.leftEdgeInput = input[length - 2];\n            narrowedInput.rightEdgeInput = input[length - 1];\n            narrowedInput.leftEdgeOutput = output[length - 2];\n            narrowedInput.rightEdgeOutput = output[length - 1];\n        }\n        else {\n            for (let i = 1; i < length; ++i) {\n                if (x <= input[i]) {\n                    narrowedInput.leftEdgeInput = input[i - 1];\n                    narrowedInput.rightEdgeInput = input[i];\n                    narrowedInput.leftEdgeOutput = output[i - 1];\n                    narrowedInput.rightEdgeOutput = output[i];\n                    break;\n                }\n            }\n        }\n    }\n    return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}